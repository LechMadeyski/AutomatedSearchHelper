[{"title": "Abstract", "paragraphs": [{"sentences": ["The C++11/14 standard offers a wealth of features aimed at helping programmers write better code.", "Unfortunately, some of these features may cause subtle programming faults, likely to go unnoticed during code reviews.", "In this paper we propose four new mutation operators for C++11/14 based on common fault patterns, which allow to verify whether a unit test suite is capable of testing against such faults.", "We validate the relevance of the proposed mutation operators by performing a case study on seven real-life software systems."]}]}, {"title": "1 Introduction", "paragraphs": [{"sentences": ["Nowadays, the process of software development relies more and more on automated software tests due to the developers interest in testing their software components early and often.", "The level of confidence in this process depends on the quality of the test suite.", "Therefore, measuring and improving the quality of the test suite has been an important subject in literature.", "Among many of the studied techniques, mutation testing is known to perform well for improving the quality of the test suite\u00a0[10]."]}, {"sentences": ["The idea of mutation testing is to help identify software faults indirectly by improving the quality of the test suite through injecting an artificial fault (i.e.", "generating a mutant) and executing the unit test suite to see whether the fault is detected\u00a0[19].", "If any of the tests fail, the mutant is said to detected, thus killed.", "On the other hand, if all the tests pass, the test suite failed to detect the mutant, thus the mutant survived.", "However, some mutants result in code which does not pass the compiler and these are called invalid mutants.", "And in other situations, a mutant fails to change the output of a program for any given input hence can never be detected\u2014these are called equivalent mutants."]}, {"sentences": ["A mutant is created by applying a transformation rule (i.e.", "mutation operator) to the code that results in a syntactic change of the program\u00a0[9].", "Given an effective set of mutation operators, mutation testing can help developers identify the weaknesses in the test suite\u00a0[1].", "Nevertheless, designing effective mutation operators requires considerable knowledge about the coding idioms and the common programming faults often made in the language\u00a0[9].", "More importantly, good mutation operators should maximize the likelihood of valid and non-equivalent mutants\u00a0[4]."]}, {"sentences": ["The first set of mutation operators were reported in King et al.", "[12].", "They were later implemented in the tool Mothra which was designed to mutate the programming language FORTRAN77.", "With the advent of the object-oriented programming paradigm, new mutation operators were proposed to cope with specific programming faults therein\u00a0[11].", "This is a common trend in mutation testing: languages evolve to get new language constructs; some of these constructs cause subtle programming faults; after which new mutation operators get designed to shield against these common faults.", "For example, with the evolution of Java related languages, mutation operators have been designed to account for concurrent code\u00a0[2], aspect-oriented programming\u00a0[7], graphical user interfaces\u00a0[18], and Android applications\u00a0[6]."]}, {"sentences": ["The C++11/14 standard (created in 2011 and 2014 respectively) offers a wealth of features aimed at helping programmers write better code\u00a0[20].", "Most notably there is more type-safety and compile-time checking (e.g.", "static_assert, override).", "Unfortunately, the standard also provides a few features that may cause subtle faults (e.g.", "lambda expressions, list initialization, ...).", "Our goal is to identify these sources of common faults and introduce new mutation operators that address them.", "While it is possible that some subset of these faults are addressed by C++99 mutation operators, previous experience shows targeted mutation operators prove useful in improving the test suite quality further\u00a0[3, 5]."]}, {"sentences": ["RQ1.", "Which categories of C++11/14 faults are most likely to be made by programmers, and what are the corresponding mutation operators?"]}, {"sentences": ["RQ2.", "To what extent do these mutation operators create valid, non-equivalent mutants?"]}, {"sentences": ["The rest of this paper is structured as follows: In Sect.", "2 we provide the necessary background information about this study, and briefly discuss the related work.", "In Sect.", "3 we discuss our approach to answering our research questions, and show our results in Sect.", "4.", "Finally, we present our conclusions in Sect.", "5 and highlight the future research directions rooted in this work."]}]}, {"title": "2 Background and Related Work", "paragraphs": [{"sentences": ["In this section we provide the necessary background information needed to comprehend the rest of the article and discuss the related work.", "First, we describe mutation testing and its related concepts.", "Then, we describe the new C++11/14 features, focusing on subtle faults that may be revealed via mutation testing."]}, {"sentences": ["Mutation testing is the process of inserting bugs into software(Mutants) using a set of rules(Mutation Operators) and then running the accompanying test suite for each inserted mutant.", "If all tests pass, the mutant survived.", "If at least one test fails, the mutant is killed.", "If the mutant causes an error during compilation of the production code, it is invalid.", "A valid mutant that does not change the semantics of the program, thus making it impossible to detect, is called equivalent."]}, {"sentences": ["An equivalent mutant is a mutant that does not change the semantics of the program, i.e.", "its output is the same as the original program for any possible input.", "Therefore, no test case can differentiate between an equivalent mutant and the original program, which makes it undesirable.", "The detection of equivalent mutants is undecidable due to the halting problem\u00a0[16].", "The only way to make sure there are no equivalent mutants in the mutant set is to manually inspect and remove all the equivalent mutants.", "However, this is impractical in practice.", "Therefore, the aim is to generate as few equivalent mutants as possible."]}, {"sentences": ["Mutation operators are the rules mutation testing tools use to inject syntactic changes into software.", "Most operators are defined as a transformation on a certain pattern found in the source code.", "The first set of mutation operators ever designed were reported in King et al.", "[12].", "These mutation operators work on basic syntactic entities of the programming language such as arithmetic, logical, and relational operators.", "Offutt et al.", "came up with a selection of few mutation operators that are enough to produce high quality test suites with a four-fold reduction of the number of mutants\u00a0[17].", "Kim et al.", "extended the set of mutation operators for object-oriented programming constructs\u00a0[11]."]}, {"sentences": ["Because of the complexity of parsing C++, building a mutation testing tool for C++ is almost equivalent to building a complete compiler\u00a0[8].", "It is only with modern tooling, e.g.", "the Clang/LLVM compiler platform, that it became possible to write such tools without an internal parser."]}, {"sentences": ["Kusano et al.", "developed CCmutator, a mutation tool for multi-threaded C/C++ programs that mutates usages of POSIX threads and the C++11 concurrency constructs, but works on LLVM\u2019s intermediate representation instead of directly on C++ source code\u00a0[13].", "Delgado-Perez et al.", "have expanded on the work done for the C language by adding class mutation operators, and created a set of C++ mutation operators\u00a0[5].", "In addition, they show that the class mutation operators compliment the traditional ones and help testers in developing better test suites."]}, {"sentences": ["C++11 was introduced in 2011 with the goal of adapting C++ and its core libraries to modern use cases of the language (e.g.", "multi-threading, genetic algorithms, ...).", "This release was followed by C++14 in 2014 with similar goals.", "The introduction of C++11/14 has changed the language to the point that earlier iterations of the language are dubbed the classical C++, and modern C++1 starts with C++11/14.", "The release of the standard was followed by real-time adoption in compilers such as Clang and G++."]}, {"sentences": ["Unfortunately, the C++11/14 standard also provides a few features that may cause subtle faults, thus where support in the form of new mutation operators would be desirable.", "In this subsection we briefly explain these features of C++11/14."]}, {"sentences": ["It is possible to have a default capture at the start of the capture list, e.g.", "\u2019=\u2019 for by-value, or \u2019&\u2019 for by-reference capture.", "This causes all variables referenced in the lambda body to be captured the specified way."]}, {"sentences": ["In C++03, this code would create the vector in ComputeLargeVector, call the copy constructor for v, which copies all elements into a newly allocated buffer, and then destroys the original.", "With move semantics, v would simply copy the internal size, capacity, and pointer to the elements in the temporary vector and set the members of the temporary vector to 0."]}, {"sentences": ["It is possible to convert an lvalue to an xvalue through std::move, which casts the object to an rvalue reference type."]}, {"sentences": ["Because Arg is a template parameter, Arg&& is a forwarding reference\u00a0[22].", "This means that it will resolve to either an lvalue or an rvalue reference depending on argument.", "If argument is an lvalue, std::forward is a no-op, and if argument is an rvalue reference, it behaves the same way std::move does."]}]}, {"title": "3 Study Design", "paragraphs": [{"sentences": ["In this section, we discuss the design of our study.", "First, we explain our evaluation criteria, and then we describe the process by which we determine the fault categories and create mutation operators.", "Finally, we present the details of our data set."]}, {"sentences": ["RQ1.", "Which categories of C++11/14 faults are most likely to be made by programmers, and what are the corresponding mutation operators?"]}, {"sentences": ["Can the mutation operator simulate a fault from the fault category we identified?"]}, {"sentences": ["Is it reasonable to assume that the software developer can create faulty code similar to the generated fault?"]}, {"sentences": ["We look at guidelines provided by experts concerning the new standards and the common pitfalls mentioned therein.", "We search for such patterns and select those that can be reconstructed into a mutation operator."]}, {"sentences": ["An effective mutation operator generates valid semantic faults.", "This means that mutation operators need to generate as few equivalent mutants as possible.", "We borrow this criterion from Delgado-Perez et al.", "who used it in their study\u00a0[4].", "It is also important for each mutant to be valid, i.e.", "the mutated program compiles without errors.", "To quantify the effectiveness of each mutation operator, we calculate the percentage of equivalent mutants among the valid mutants after filtering the easily-detectable equivalent mutants.", "The mutation operator score is then calculated by deducting the mentioned percentage from 100% (see Eq.", "1).", "For each mutation operator, we provide methods to filter easily-detectable equivalent mutants."]}, {"sentences": ["To see how our operators work in real-life scenarios, we looked at seven open source projects that are using C++11/14 (see Table\u00a01).", "Our analysis consists of applying our mutation operators to create all possible mutants.", "We do this by manually searching for the code patterns that match (using grep).", "Then, we manually categorize the resulting mutants into invalid, equivalent, and valid non-equivalent mutants.", "If a mutant did not change the semantics of the program, we classified it as an equivalent mutant.", "If the operator created a non-compilable program, we classified the mutant as invalid.", "Otherwise, we considered the mutant as valid non-equivalent."]}, {"sentences": ["In this subsection, we present the details of our data set.", "Our data set is publicly available in the replication package available at https://www.parsai.net/files/research/ICTSSRepPak.zip."]}, {"sentences": ["Project statistics"]}, {"sentences": ["Project"]}, {"sentences": ["Commit"]}, {"sentences": ["Size (Lines of Code)"]}, {"sentences": ["Number of commits"]}, {"sentences": ["Team size"]}, {"sentences": ["Production"]}, {"sentences": ["Test"]}, {"sentences": ["i-score"]}, {"sentences": ["c86cd3d"]}, {"sentences": ["108K"]}, {"sentences": ["3.5K"]}, {"sentences": ["5358"]}, {"sentences": ["14"]}, {"sentences": ["C++React"]}, {"sentences": ["1f6ddb7"]}, {"sentences": ["11K"]}, {"sentences": ["2K"]}, {"sentences": ["417"]}, {"sentences": ["1"]}, {"sentences": ["EntityX"]}, {"sentences": ["6389b1f"]}, {"sentences": ["9K"]}, {"sentences": ["1K"]}, {"sentences": ["296"]}, {"sentences": ["28"]}, {"sentences": ["Antonie"]}, {"sentences": ["59deb0d"]}, {"sentences": ["9K"]}, {"sentences": ["0.1K"]}, {"sentences": ["306"]}, {"sentences": ["2"]}, {"sentences": ["Json"]}, {"sentences": ["a09193e"]}, {"sentences": ["8K"]}, {"sentences": ["18K"]}, {"sentences": ["1973"]}, {"sentences": ["59"]}, {"sentences": ["Corrade"]}, {"sentences": ["ff3b351"]}, {"sentences": ["6.5K"]}, {"sentences": ["9.1K"]}, {"sentences": ["1898"]}, {"sentences": ["10"]}, {"sentences": ["termdb"]}, {"sentences": ["bd0fb4a"]}, {"sentences": ["783"]}, {"sentences": ["153"]}, {"sentences": ["26"]}, {"sentences": ["2"]}, {"sentences": ["i-score is an interactive intermedia sequencer, built in Qt."]}, {"sentences": ["C++React is a C++11 reactive programming library, based on signals and event streams."]}, {"sentences": ["EntityX is an Entity Component System that uses C++11 features."]}, {"sentences": ["Antonie is a processor of DNA reads, developed at the Bertus Beaumontlab of the Bionanoscience Department of Delft University of Technology."]}, {"sentences": ["Json is a single-header library for working with Json with modern C++."]}, {"sentences": ["Corrade is a C++11/14 utility library, including several container classes, a signal-slot connection library, a unit test framework, a plugin management library and a collection of other small utilities."]}, {"sentences": ["termdb is a small C++11 library for parsing command-line arguments."]}]}, {"title": "4 Results", "paragraphs": [{"sentences": ["In this section, we present the results of our research.", "For each mutation operator, first we give its definition, then we discuss the motivation behind it to answer RQ1, and finally we provide our analysis of the data set to answer RQ2."]}, {"sentences": ["It might not compile - for example, unique_ptr3 elements are not copyable.", "This is problematic both for users who won\u2019t understand the resulting compiler errors, and for users writing generic code that\u2019ll happily compile until someone instantiates it for movable-only elements."]}, {"sentences": ["It might misbehave at runtime - for example, elem = val; will modify the copy, but not the original element in the range.", "Additionally, &elem will be invalidated after each iteration."]}, {"sentences": ["It might be inefficient - for example, unnecessarily copying std::string."]}, {"sentences": ["From a mutation testing perspective, the second reason is the main motivation to create a mutation operator.", "In the case of a range-based for loop that modifies the elements of a container in-place, the correct and generic way to write it is for (auto&& elem : range).", "For all cases except for proxy objects and move-only ranges, for (auto& elem : range) works as well."]}, {"sentences": ["Results of FOR operator"]}, {"sentences": ["Project"]}, {"sentences": ["Total"]}, {"sentences": ["Invalid"]}, {"sentences": ["Equivalent"]}, {"sentences": ["Easily detectable"]}, {"sentences": ["Score"]}, {"sentences": ["i-score"]}, {"sentences": ["251"]}, {"sentences": ["101"]}, {"sentences": ["115"]}, {"sentences": ["110"]}, {"sentences": ["87.5%"]}, {"sentences": ["Corrade"]}, {"sentences": ["24"]}, {"sentences": ["1"]}, {"sentences": ["13"]}, {"sentences": ["13"]}, {"sentences": ["100%"]}, {"sentences": ["Json"]}, {"sentences": ["1"]}, {"sentences": ["0"]}, {"sentences": ["0"]}, {"sentences": ["0"]}, {"sentences": ["100%"]}, {"sentences": ["EntityX"]}, {"sentences": ["2"]}, {"sentences": ["0"]}, {"sentences": ["2"]}, {"sentences": ["2"]}, {"sentences": ["N/A"]}, {"sentences": ["termdb"]}, {"sentences": ["0"]}, {"sentences": ["0"]}, {"sentences": ["0"]}, {"sentences": ["0"]}, {"sentences": ["N/A"]}, {"sentences": ["C++React"]}, {"sentences": ["8"]}, {"sentences": ["0"]}, {"sentences": ["6"]}, {"sentences": ["6"]}, {"sentences": ["100%"]}, {"sentences": ["Antonie"]}, {"sentences": ["39"]}, {"sentences": ["10"]}, {"sentences": ["18"]}, {"sentences": ["18"]}, {"sentences": ["100%"]}, {"sentences": ["Analysis (RQ2).", "Invalid Mutants: The invalid mutants are comprised of two groups.", "The majority of the invalid loops were over containers of move-only types.", "Of the invalid mutants in i-score, 33 were containers of pointers to virtual interface classes with custom dereferencing iterators, making the mutant try to instantiate a non-instantiable type.", "Both of these cases can be easily checked when generating the mutants."]}, {"sentences": ["Equivalent Mutants: In the majority of equivalent cases, the body of the loop did not mutate the referenced element in the container, thus making it equivalent to a loop with an added const qualifier.", "This is relatively easy to verify automatically, hence such mutants are listed as detectable.", "Only a handful of equivalent cases were loops that did mutate the elements of the container, but the container never gets used after the loop finishes.", "This would require more complicated static analysis."]}, {"sentences": ["Motivation (RQ1).", "This operator is based on the warnings on default capture modes in Core Guideline F53 and Meyers\u2019 31st item\u00a0[15, 21].", "This mutation operator results in code that leads to undefined behavior if the lambda is executed in a non-local context, because the references to local variables are not valid.", "This can happen when the lambda is pushed up the call stack or sent to a different thread for asynchronous execution."]}, {"sentences": ["Results of LMB operator"]}, {"sentences": ["Project"]}, {"sentences": ["Total"]}, {"sentences": ["Invalid"]}, {"sentences": ["Equivalent"]}, {"sentences": ["Easily detectable"]}, {"sentences": ["Score"]}, {"sentences": ["i-score"]}, {"sentences": ["189"]}, {"sentences": ["0"]}, {"sentences": ["113"]}, {"sentences": ["101"]}, {"sentences": ["86.3%"]}, {"sentences": ["Corrade"]}, {"sentences": ["0"]}, {"sentences": ["0"]}, {"sentences": ["0"]}, {"sentences": ["0"]}, {"sentences": ["N/A"]}, {"sentences": ["Json"]}, {"sentences": ["0"]}, {"sentences": ["0"]}, {"sentences": ["0"]}, {"sentences": ["0"]}, {"sentences": ["N/A"]}, {"sentences": ["EntityX"]}, {"sentences": ["0"]}, {"sentences": ["0"]}, {"sentences": ["0"]}, {"sentences": ["0"]}, {"sentences": ["N/A"]}, {"sentences": ["termdb"]}, {"sentences": ["0"]}, {"sentences": ["0"]}, {"sentences": ["0"]}, {"sentences": ["0"]}, {"sentences": ["N/A"]}, {"sentences": ["C++React"]}, {"sentences": ["1"]}, {"sentences": ["0"]}, {"sentences": ["0"]}, {"sentences": ["0"]}, {"sentences": ["100%"]}, {"sentences": ["Antonie"]}, {"sentences": ["0"]}, {"sentences": ["0"]}, {"sentences": ["0"]}, {"sentences": ["0"]}, {"sentences": ["N/A"]}, {"sentences": ["Analysis (RQ2).", "Invalid Mutants: We did not witness any invalid mutants generated by this operator in our data set."]}, {"sentences": ["Motivation (RQ1).", "There are often two possible errors in relation to forwarding semantics (which Meyers warns about in his items 24 and 25\u00a0[15]): forgetting to use std::forward (and thus passing both lvalues and rvalues on as lvalues) or moving instead of forwarding (and thus passing lvalues on as rvalues to be moved from)."]}, {"sentences": ["Both calls result in Args being \\(  \\texttt {[std::string \\& ,std::unique\\_ptr<\\texttt {int}> \\& \\& ]}\\), which makes std::forward correctly forward the first argument as lvalue and the second as rvalue.", "Forgetting to use std::forward results in both arguments being forwarded as lvalues, which fails to compile since std::unique_ptr is a move-only type.", "When forgetting to forward, code will always either compile and default to copying the types, or fail to compile because a move-only type is used.", "Since for all types, the only visible effect of doing a copy instead of a move is a performance degradation, this would not be a useful operator for testing purposes."]}, {"sentences": ["Replacing the std::forward with std::move, however, does has the potential to change program behavior.", "With construct mutated as in the code sample above, the string text will be moved from in the first call, and the second call results in unspecified behavior.", "In most standard library implementations, w2 will end up with an empty text.", "Meyers argues that it is easy to confuse rvalue and forwarding references because of their identical syntax, making this a likely fault for developers to make."]}, {"sentences": ["Results of FWD operator"]}, {"sentences": ["Project"]}, {"sentences": ["Total"]}, {"sentences": ["Invalid"]}, {"sentences": ["Equivalent"]}, {"sentences": ["Easily detectable"]}, {"sentences": ["Score"]}, {"sentences": ["i-score"]}, {"sentences": ["71"]}, {"sentences": ["13"]}, {"sentences": ["18"]}, {"sentences": ["9"]}, {"sentences": ["81.6%"]}, {"sentences": ["Corrade"]}, {"sentences": ["5"]}, {"sentences": ["0"]}, {"sentences": ["0"]}, {"sentences": ["0"]}, {"sentences": ["100%"]}, {"sentences": ["Json"]}, {"sentences": ["14"]}, {"sentences": ["0"]}, {"sentences": ["14"]}, {"sentences": ["6"]}, {"sentences": ["0%"]}, {"sentences": ["EntityX"]}, {"sentences": ["7"]}, {"sentences": ["0"]}, {"sentences": ["1"]}, {"sentences": ["1"]}, {"sentences": ["100%"]}, {"sentences": ["termdb"]}, {"sentences": ["0"]}, {"sentences": ["0"]}, {"sentences": ["0"]}, {"sentences": ["0"]}, {"sentences": ["N/A"]}, {"sentences": ["C++React"]}, {"sentences": ["160"]}, {"sentences": ["0"]}, {"sentences": ["17"]}, {"sentences": ["15"]}, {"sentences": ["98.6%"]}, {"sentences": ["Antonie"]}, {"sentences": ["0"]}, {"sentences": ["0"]}, {"sentences": ["0"]}, {"sentences": ["0"]}, {"sentences": ["N/A"]}, {"sentences": ["Equivalent Mutants: There are three categories of equivalence for this operator.", "The first is where std::forward gets used within a decltype or noexcept context, where the operator either changes nothing, or makes the code fail to compile.", "This is why we classify these as detectable equivalent mutants.", "The second case is where the forwarded argument never gets stored, which makes irrelevant the difference between std::forward, std::move, and passing by reference.", "The third and final category is where the callees are guaranteed to not take rvalue references or value parameters of movable types.", "Of these three categories, the first is easily detectable by filtering out mutants within a decltype or noexcept expression.", "The second would require sophisticated flow analysis which is why we listed them as not easily-detectable.", "The last category can be detected if it is feasible to find all possible callees and see whether they take any rvalue references or value parameters of movable types.", "This is only feasible for mutants calling functions that cannot be overloaded by external code, since it is otherwise theoretically possible to introduce a new overload of the called function that takes a parameter of a type with a destructive move, making the mutant non-equivalent.", "The mutants for which this analysis is possible are listed as detectable in our analysis."]}, {"sentences": ["Results of INI operator"]}, {"sentences": ["Project"]}, {"sentences": ["Total"]}, {"sentences": ["Invalid"]}, {"sentences": ["Equivalent"]}, {"sentences": ["Easily detectable"]}, {"sentences": ["Score"]}, {"sentences": ["i-score"]}, {"sentences": ["1"]}, {"sentences": ["0"]}, {"sentences": ["0"]}, {"sentences": ["0"]}, {"sentences": ["100%"]}, {"sentences": ["Corrade"]}, {"sentences": ["0"]}, {"sentences": ["0"]}, {"sentences": ["0"]}, {"sentences": ["0"]}, {"sentences": ["N/A"]}, {"sentences": ["Json"]}, {"sentences": ["0"]}, {"sentences": ["0"]}, {"sentences": ["0"]}, {"sentences": ["0"]}, {"sentences": ["N/A"]}, {"sentences": ["EntityX"]}, {"sentences": ["0"]}, {"sentences": ["0"]}, {"sentences": ["0"]}, {"sentences": ["0"]}, {"sentences": ["N/A"]}, {"sentences": ["termdb"]}, {"sentences": ["1"]}, {"sentences": ["0"]}, {"sentences": ["0"]}, {"sentences": ["0"]}, {"sentences": ["100%"]}, {"sentences": ["C++React"]}, {"sentences": ["0"]}, {"sentences": ["0"]}, {"sentences": ["0"]}, {"sentences": ["0"]}, {"sentences": ["N/A"]}, {"sentences": ["Antonie"]}, {"sentences": ["18"]}, {"sentences": ["0"]}, {"sentences": ["0"]}, {"sentences": ["0"]}, {"sentences": ["100%"]}, {"sentences": ["Equivalent Mutants: There are only a few corner cases for std::vector where this operator results in equivalence (e.g.", "Code Excerpt\u00a01.14)."]}, {"sentences": ["In both of these cases, the mutated initializer results in the same vector as the original.", "Given the number of times this pattern was observed in our data set (20 instances in all projects), it is unlikely that such equivalent mutants are found in any significant number."]}, {"sentences": ["Generated mutants"]}, {"sentences": ["Mutation operator scores"]}, {"sentences": ["Figure\u00a02 shows the mutation operator score for each mutation operator.", "It is clear that all mutation operators are within reasonable boundaries regarding the percentage of generated hard to detect equivalent mutants when compared to other C++ mutation operators (e.g.", "Delgado-Perez et al.", "[4]).", "Overall, we found that these mutation operators have a high mutation operator score, with all of them generating very few equivalent mutants (13.5% or less of the total number of mutants)."]}, {"sentences": ["One of the noticeable trends among these mutation operators is their tendency to generate lots of mutants in a single project, and few in others.", "For example, INI generated 18 mutants in Antonie, and 2 in all other projects, while LMB generated 189 mutants in i-score and only 1 in others.", "Other than the size of the projects, we found that the adoption of the new syntax has not been uniform in all of the projects, i.e.", "some projects make use of mostly a single new syntactic feature and not all of them."]}]}, {"title": "5 Conclusions and Future Work", "paragraphs": [{"sentences": ["In this study, we created a set of mutation operators that target the common faults introduced by C++11/14 syntactic features.", "We collected advice about the new C++11/14 syntax from authoritative sources, and created four new statement-level mutation operators (FOR, LMB, FWD, and INI).", "For each mutation operator, we discussed the motivation behind its creation and the type of faults they generate.", "We used Mutation Operator Score as a way to measure the effectiveness of each mutation operator.", "For this, we selected 7 real-life C++11/14 projects, and counted the number of valid, invalid, easily detectable and hard to detect equivalent mutants generated by each mutation operator for each project.", "Our results show that all of the introduced mutation operators generate at most 13.5% hard to detect equivalent mutants.", "The high operator scores indicate that these mutation operators are a useful addition to the mutation operators suggested previously in literature."]}, {"sentences": ["Several aspects of this study can be researched further.", "In particular, the use of our proposed mutation operators alongside traditional and class mutation operators may result in finding multiple redundancies among these mutation operators.", "In addition, a comparative study similar to Delgado-Perez et al.", "[5] between these mutation operator sets would provide more insight into the usefulness of each set of operators depending on the context."]}]}, {"title": "Notes", "paragraphs": [{"sentences": ["This work is sponsored by (a) the ITEA3 ReVaMP\\({}^2\\) Project (number 15010), sponsored by VLAIO\u2014Flanders Innovation Sponsoring Agency; (b) Flanders Make vzw, the strategic research centre for the manufacturing industry."]}]}, {"title": "References", "paragraphs": []}, {"title": "Copyright information", "paragraphs": []}]