[{"title": "Abstract", "paragraphs": [{"sentences": [" Abstract:Software testing techniques have advanced significantly over several decades; however, most of current techniques still test a target program as it is, and fail to utilize valuable information of diverse test executions on many variants of the original program in test generation.", "This paper proposes a new direction for software testing - Invasive Software Testing (IST).", "IST first generates a set of target program variants m1, \u22ef, mnfrom an original target program p by applying mutation operations1, \u22ef, \u03bcn.", "Second, given a test suite T, IST executes m1, \u22ef, mnwith T and records the test runs which increase test coverage compared to p with T. Based on the recorded information, IST generates guideposts for automated test generation on p toward high test coverage.", "Finally, IST generates test inputs on p with the guideposts and achieves higher test coverage.", "We developed DEMINER which implements IST for C programs through software mutation and concolic testing.", "Further, we showed the effectiveness of DEMINER on three real-world target programs Busybox-ls, Busybox-printf, and GNU-find.", "The experiment results show that the amount of the improved branch coverage by DEMINER is 24.7% relatively larger than those of the conventional concolic testing techniques on average."]}]}, {"title": "Introduction", "paragraphs": [{"sentences": ["Software testing has been a de-facto standard method to assess and improve software quality.", "Although software testing techniques have advanced significantly over several decades, most of them (either manual or automated ones) still test a target program as it is without modifying the target program.", "In contrast, other engineering disciplines such as mechanical engineering have used invasive testing (or destructive testing) as a standard technique to obtain information on a target object (i.e., analyzing a target object by inducing physical forces on it) which cannot be provided by a non-invasive testing."]}, {"sentences": ["Note that a software program has the following ideal characteristics for invasive testing:"]}, {"sentences": ["it is almost free to make copies of a software program."]}, {"sentences": ["it is easy to modify/destroy a software program (in a source code or binary level)."]}, {"sentences": []}, {"sentences": ["However, owing to high complexity of software, it is non-trivial to re-interpret/re-analyze various dynamic information obtained from many modified variants of the original target program (e.g., what conclusion can we make on an original program \\$p\\$ by observing crashes on a variant \\$m_{1}\\$ of \\$p\\$ with a test case \\$t_{1}\\$?", "For example, crash of \\$m_{1}\\$ with \\$t_{1}\\$ does not necessarily mean that \\$p\\$ will crash with \\$t_{1}\\$).", "Consequently, software testing so far has failed to improve testing effectiveness further by utilizing useful information from diverse test executions on many variants of a target program."]}, {"sentences": ["To resolve the aforementioned problem, this paper proposes a new direction for software testing: Invasive Software Testing (IST).", "This technique consists of the following three stages:"]}, {"sentences": ["extract/learn useful information of an original target program \\$p\\$ for high test coverage through the diverse test exploration of various variants of \\$p\\$"]}, {"sentences": ["create guideposts by using the extracted information, which can guide test generation for high test coverage"]}, {"sentences": ["generate test executions on \\$p\\$ following/satisfying the guideposts inserted in \\$p\\$"]}, {"sentences": []}, {"sentences": ["A core idea of IST is to create guideposts by learning knowledge on an original target program \\$p\\$ from diverse test executions of many mutated versions \\$m_{1}, \\ldots, m_{n}\\$ of \\$p\\$, which can effectively lead test generation to cover various executions of \\$p\\$ that achieve high test coverage."]}, {"sentences": ["We developed DeMiner (guiDEed test generation using MutatIoN ExploRation) which realizes IST to improve test coverage.", "DeMiner operates as follows:"]}, {"sentences": ["DeMiner generates target program variants \\$m_{1}, \\ldots, m_{n}\\$ from an original target program \\$p\\$ by applying mutation \\$\\mu_{1}, \\ldots, \\mu_{n}\\$, respectively."]}, {"sentences": ["given a test suite \\$T\\$, DeMiner executes \\$m_{1}, \\ldots, m_{n}\\$ with \\$T\\$ and records test runs covering new lines not covered on \\$p\\$ with \\$T\\$ and corresponding mutation operator instances."]}, {"sentences": ["Based on the recorded information, DeMiner constructs guideposts to guide test generation on \\$p\\$ to improve test coverage."]}, {"sentences": ["DeMiner applies concolic testing on \\$p\\$ with an inserted guidepost to generate new test executions that follow the guideposts and achieve high test coverage."]}, {"sentences": ["DeMiner overview"]}, {"sentences": ["View All"]}, {"sentences": []}, {"sentences": ["Figure 1 shows an overview of DeMiner.", "Suppose that nodes \\$l_{4}\\$ and \\$l_{6}\\$ in the leftmost box indicate uncovered lines in a target program \\$p\\$ with a test case \\$t\\in T\\$.", "Also, suppose that DeMiner generates a mutant \\$m_{1}\\$ from \\$p\\$ via mutation \\$\\mu_{1}\\$ (i.e., replace \\$l_{1}\\$ with \\$l_{1}^{\\prime}\\$), and \\$t\\$ covers \\$l_{6}\\$ on \\$m_{1}\\$.", "From this mutant execution, DeMiner captures a partial state \\$c_{1}\\$ infected by \\$\\mu_{1}\\$ as a key for \\$t\\$ to covering \\$l_{6}\\$, and then DeMiner inserts guidepost (\\$c_{1}\\$) right before the mutation site of \\$\\mu_{1}\\$ in \\$p\\$.", "Finally, DeMiner automatically generates new tests on \\$p\\$ (e.g., \\$t_{1}\\$) with the inserted guidepost which follow/satisfy the guidepost condition \\$c_{1}\\$.", "DeMiner repeats this process for all other coverage-increasing mutants each of which increases line coverage by covering lines that were not covered on \\$p\\$ with \\$t\\$."]}, {"sentences": ["We studied the effectiveness of DeMiner on three real-world target programs Busybox-ls, Busybox-printf, and GNU-find.", "The experiment results show that the amount of the improved branch coverage by DeMiner is 24.7% relatively larger than those of the conventional concolic testing techniques on average.", "(Section V-D)."]}, {"sentences": ["The contributions of this paper are as follows:"]}, {"sentences": ["As far as the authors know, this paper is first to technically proposes invasive software testing to explicitly generate highly effective test inputs."]}, {"sentences": ["We developed DeMiner which realizes IST by generating diverse test executions guided by guideposts created by learning coverage-increasing conditions from various mutant executions."]}, {"sentences": ["We performed case studies to demonstrate that DeMiner can increase branch and line coverage compared to the conventional concolic testing through three real-world C programs (i.e., Busybox-ls, Busybox-printf, and GNU-find)."]}, {"sentences": []}, {"sentences": ["The remainder of this paper is organized as follows.", "Section II shows a motivating example showing a limitation of a current automated test generation technique and how IST can overcome it.", "Section III explains DeMiner, and Section IV describes research questions and the experiment setup to study the effectiveness of DeMiner.", "Sections V and VI report and discuss the experiment results.", "Finally, Section VII concludes this paper with future work."]}, {"sentences": ["Example whose lines 9\u201310 are difficult to cover by concolic testing"]}, {"sentences": ["View All"]}, {"sentences": []}]}, {"title": "Motivating Example", "paragraphs": [{"sentences": ["Although automated test generation techniques such as concolic testing [1]\u2013[2][3] generate test inputs achieving high test coverage, they sometimes fail to cover target branches due to several limitations of the techniques (e.g., external binary library APIs [4]\u2013[5][6], symbolic pointers [7]\u2013[8][9], loop conditions with symbolic bound variables [10]\u2013[11][12])."]}, {"sentences": ["For example of get_max in Figure 2, concolic testing (almost) fails to cover the branch consisting of Lines 9\u201310.", "Figure 2 shows get_max which receives an array of integers a and an unsigned integer sz that represents the number of valid target elements in a.", "Suppose that concolic testing declares every element of a and sz as symbolic values, and uses DFS (Depth First Search) as a concolic search strategy."]}, {"sentences": ["Suppose that an initial input for get_max has"]}, {"sentences": ["sz = 100, and"]}, {"sentences": ["a is sorted in a strictly ascending order, and"]}, {"sentences": ["every element of a is positive"]}, {"sentences": []}, {"sentences": ["Then, the symbolic path formula \\$\\phi_{1}\\$ obtained from an execution with the initial input is as follows:\\begin{align*}&\\phi_{1}=(0 < sz)\\wedge(0 < a[0])\\wedge(1 < sz)\\wedge(a[0] < a[1])\\wedge\\ldots\\wedge\\\\&\\qquad \\ \\ \\ (99 < sz)\\wedge(a[98] < a[99])\\wedge(100 \\nless sz)\\wedge(a[99] > 0)\\end{align*}View Source\\begin{align*}&\\phi_{1}=(0 < sz)\\wedge(0 < a[0])\\wedge(1 < sz)\\wedge(a[0] < a[1])\\wedge\\ldots\\wedge\\\\&\\qquad \\ \\ \\ (99 < sz)\\wedge(a[98] < a[99])\\wedge(100 \\nless sz)\\wedge(a[99] > 0)\\end{align*}"]}, {"sentences": ["Note that the subsequent concolic executions (almost) fail to cover Lines 9\u201310 for the following reason."]}, {"sentences": ["After the initial execution, concolic testing negates the last branch condition (i.e., \\$a[99] > 0\\$) and the resulting symbolic path constraint \\$\\phi_{1}^{\\prime}\\$ is unsatisfiable.", "This is because \\${a[0]}\\$ should be positive (\\$\\mathrm{i}.\\mathrm{e}.,\\ 0 < a[0]\\ \\text{in}\\ \\phi_{1}^{\\prime}\\$) and \\$a\\$ is sorted in a strictly ascending order (\\$\\mathrm{i}.\\mathrm{e}.,\\ a[0] < a[1]\\ <\\ \\ldots < \\ a[99]\\ \\text{in}\\ \\phi_{1}^{\\prime}\\$).", "Subsequently, concolic testing negates second last condition in \\$\\phi_{1}\\$ (i.e., \\$100 \\nless sz\\$) and generates the second input with \\$\\text{sz} =101\\$, which still does not cover Lines 9\u201310.", "The symbolic path formula \\$\\phi_{2}\\$ obtained from the second input is longer than \\$\\phi_{1}\\$ by iterating the for-loop (Lines 3\u20135) one more time with \\$i=100\\$ as follows:\\begin{align*}&\\phi_{2}=(0 < sz)\\wedge(0 < a[0])\\wedge(1 < sz)\\wedge(a[0] < a[1])\\wedge\\ldots\\wedge\\\\&\\quad\\ (100 < sz)\\wedge(a[99] < a[100])\\wedge(101 \\nless sz)\\wedge(a[100] > 0)\\end{align*}View Source\\begin{align*}&\\phi_{2}=(0 < sz)\\wedge(0 < a[0])\\wedge(1 < sz)\\wedge(a[0] < a[1])\\wedge\\ldots\\wedge\\\\&\\quad\\ (100 < sz)\\wedge(a[99] < a[100])\\wedge(101 \\nless sz)\\wedge(a[100] > 0)\\end{align*}"]}, {"sentences": ["Similarly, concolic testing keeps increasing the loop bound sz and generates a large number of test inputs but fails to cover Lines 9\u201310."]}, {"sentences": ["In contrast, DeMiner can cover Lines 9\u201310 by generating a guidepost by learning from mutant executions as follows.", "Suppose that DeMiner generates a mutant of get_max (saying \\$m_{3}\\$) that replaces the loop condition at Line 3 (i.e., i < sz) with i==sz.", "The execution of \\$m_{3}\\$ with the initial input does not enter the loop and covers Lines 8\u20139.", "Then, DeMiner learns from this mutant execution and generates a guidepost guidepost (0==sz) between Line 2 and Line 3 of get_max (see Section III-C for the detail of guidepost construction)."]}, {"sentences": ["Since guidepost (\\$c\\$) is a macro of if (!c) exit(0);, the initial execution terminates at the guidepost because the execution does not satisfy the guidepost condition (i.e., 0==sz).", "After that, the concolic testing generates a next test input which has sz==0 by solving the symbolic path constraint obtained by negating the last branch condition (i.e., the guidepost condition 0==sz).", "Finally, get_max reaches Lines 8\u20139 with this test input generated with the guide of the guidepost."]}]}, {"title": "DeMiner Framework", "paragraphs": [{"sentences": ["DeMiner employs mutation to generate diverse variants/mutants \\$m_{1}, \\ldots, m_{n}\\$ of a target program \\$p\\$ to generate various mutant executions to reach corner-case unreached statements of \\$p\\$.", "By using the information on mutant executions that reach new lines, DeMiner infers a precondition to cover the unreached lines.", "Then, it feeds these program conditions in the form of a guidepost to concolic testing to guide symbolic executions to cover these new lines in \\$p\\$."]}, {"sentences": ["We conjecture that, even with limited test inputs, program mutation can effectively diversify program executions by applying various mutation operations at different execution points, because there exists a large set of mutation operators that induce diverse program changes at various program locations.", "The generation of mutant executions is scalable, because mutant generation does not require sophisticated semantic analysis and it can be parallelized over a large number of computing nodes."]}, {"sentences": ["Figure 3 describes the DeMiner process generating new test inputs \\$T^{\\prime}\\$.", "Initially, DeMiner takes source code of an original target program \\$p\\$, and a set of test inputs \\$T\\ = \\{t_{1}, t_{2}, \\ldots, t_{k}\\}\\$ as inputs.", "Then, DeMiner operates in the following three phases:"]}, {"sentences": ["Discovery of coverage-increasing mutants DeMiner generates and runs various mutants of a target program with \\$T\\$ so that some mutant executions cover unreached lines of \\$p\\$ as the mutation turns a program state to a new one leading to the unreached lines by chance."]}, {"sentences": ["Guidepost construction Based on the mutant executions that cover unreached lines, DeMiner infers program conditions of the executions covering the unreached lines as guideposts.", "Then, DeMiner generates multiple copies of \\$p\\$ each of which has one guidepost."]}, {"sentences": ["Guided test generation DeMiner runs concolic testing on the copies of \\$p\\$ with the guideposts to generate test executions that follow/satisfy the guideposts to achieve the unreached lines covered at Phase 1."]}, {"sentences": []}, {"sentences": ["The remainder of this section describes each phase in detail."]}, {"sentences": ["This phase aims at finding mutants whose executions cover some code lines that are not covered by running the original program \\$p\\$ with a set of test input \\$T\\$.", "DeMiner constructs mutants \\$m_{1}, m_{2}, \\ldots, m_{n}\\$ by mutating expressions \\$e_{1}, e_{2}, \\ldots, e_{n}\\$ in \\$p\\$ respectively, and then runs the mutants with \\$T\\$.", "As the first step, DeMiner runs \\$p\\$ with \\$T\\$ to measure baseline coverage \\$C_{p}\\$ of \\$p\\$ with \\$T\\$.", "Then, total 52 mutation operators (see Table I) are applied to every mutation point of \\$p\\$ to generate mutants.", "DeMiner generates mutants at line \\$l\\$ only if \\$l\\$ is reached by at least one test input in \\$T\\$."]}, {"sentences": ["Table I shows names and categories of the mutation operators [13] used by DeMiner.", "DeMiner uses only expression-level mutation operators because DeMiner focuses on a single expression change that increases coverage.", "DeMiner does not use statement-level mutation operators (e.g., SSDL(statement deletion), SBRC(replacement of break with return)).", "This is because they may change evaluations of multiple expressions/variables at the same time, which makes monitoring and formulating mutation effect as a guidepost difficult.", "Also, DeMiner does not employ mutation operators on pointer dereference or pointer arithmetics.", "This is because a corresponding guidepost condition will be an expression on a pointer variable but concolic testing may not generate test inputs to satisfy such guidepost condition (i.e., concolic testing tools do not support a general symbolic pointer)."]}, {"sentences": ["The overall process of DeMiner"]}, {"sentences": ["View All"]}, {"sentences": []}, {"sentences": ["DeMiner runs each mutant \\$m_{i}\\$ with test inputs \\$T\\$ to measure \\$C_{m_{i}}\\$ (i.e., lines of \\$m_{i}\\$ covered by \\$T\\$) 1.", "After the mutant executions, it collects all mutants whose executions cover at least one unreached line as a set of coverage-increasing mutants \\$M_{All}=\\{m_{i}\\vert C_{m_{i}}-C_{p} \\neq \\emptyset\\}\\$."]}, {"sentences": ["Finally, DeMiner selects a subset of the coverage-increasing mutants \\$M \\subseteq M_{All}\\$ that are passed to the next phase (see Section III-C).", "DeMiner tries to select \\$M\\$ as a minimal set of the coverage-increasing mutants which covers the same set of the unreached lines covered by \\$M_{All}\\$.", "We found that many coverage-increasing mutants redundantly cover the same set of unreached lines.", "Thus, we believe that this mutant selection method reduces the runtime cost of the subsequent analyses while not hurting testing effectiveness much."]}, {"sentences": ["The mutant selection is made by a greedy heuristic algorithm, which initially defines \\$M\\$ and \\$C_{M}\\$ as empty sets.", "\\$M\\$ holds selected mutants and \\$C_{M}\\$ contains the unreached lines covered by the mutants in \\$M\\$.", "After initialization, the algorithm selects a mutant \\$m\\$ in \\$M_{All}-M\\$ that covers the most unreached lines, and then update \\$M\\$ and \\$C_{M}\\$ by including \\$m\\$, correspondingly (i.e., \\$M \\leftarrow M\\cup\\{m\\}\\$ and \\$C_{M} \\leftarrow C_{M} \\cup C_{m}\\$).", "If ties exist, the algorithm randomly picks one of them.", "The selection continues until the set of the unreached lines covered by the mutants in \\$M\\$ is equal to that of \\$M_{All}\\$ (i.e., \\$C_{M}-C_{p}=C_{M_{All}}-C_{p})\\$."]}, {"sentences": ["From the executions of the coverage-increasing mutants obtained from Phase 1, DeMiner infers a precondition at a program location to cover the unreached lines.", "DeMiner expresses such a precondition as a guidepost encoded as an if-statement that continues the execution if the condition is satisfied, or terminates the execution otherwise (i.e., guidepost (exp) \u2261 if (!exp) exit (0);).", "A guidepost embeds the knowledge on the coverage-increasing executions of the mutants.", "Note that a guidepost prunes executions without changing the behaviors of a target program.", "Thus, a guidepost guides concolic testing on a target program \\$p\\$ to generate tests toward the observed coverage-increasing executions."]}, {"sentences": ["To infer guideposts from the selected mutants \\$M\\ = \\{m_{1}, m_{2}, \\ldots, m_{l}\\}\\$, DeMiner first re-runs each mutant \\$m_{i} \\in M\\$ to inspect the mutation effects (i.e., infection) to cover the unreached lines.", "Since \\$m_{i}\\$ has a mutation on a single expression \\$e_{i}\\$, we suspect that a cause of the coverage increase is the evaluation of \\$e_{i}\\$ to a different value."]}, {"sentences": ["For each \\$m_{i}\\$, DeMiner identifies all runtime evaluations of the mutated expression as coverage-increasing values \\$V_{i}= \\{v_{1}^{i}, v_{2}^{i}, \\ldots, v_{u}^{i}\\}\\$.", "To extract \\$V_{i}\\$ from the executions of \\$m_{i}\\$, DeMiner instruments \\$m_{i}\\$ by inserting a probe exporting evaluation results of the mutated expression."]}, {"sentences": ["Once the coverage-increasing values of \\$m_{i}\\$ are captured as \\$V_{i}\\$, DeMiner constructs guideposts in \\$p\\$.", "Each guidepost is inserted immediately before the mutation site of \\$m_{i}\\$ (i.e., \\$e_{i})\\$ such that a guidepost executes immediately before \\$e_{i}\\$ is evaluated.", "A guidepost checks if \\$e_{i}\\$ is evaluated to one of the values in \\$V_{i}\\$.", "DeMiner constructs two types of guideposts from \\$V_{i}\\$ as follows:"]}, {"sentences": ["Single-value guidepost"]}, {"sentences": ["For each \\$v_{j}^{i}\\in V_{i}\\$, a single-value guidepost is created to check if \\$e_{i}\\$ is evaluated to \\$v_{j}^{i}\\$ for the first time.", "This condition is encoded as guidepost (\\$e_{i}==v_{j}^{i}\\$) for \\$v_{j}^{i}\\in V_{i}\\$."]}, {"sentences": ["Multi-value guidepost"]}, {"sentences": ["For \\$m_{i}\\$ with multiple coverage-increasing values (i.e., \\$\\vert V_{i}\\vert > 1)\\$), DeMiner additionally creates a multi-value guidepost that checks \\$e_{i}\\$ is always evaluated to one of the coverage-increasing values in \\$V_{i}\\$.", "Thus, the condition of a multi-value guidepost is formed as \\$\\text{guidepost}\\ ((e_{i}== v_{1}^{i})\\vee\\ldots\\vee(e_{i}==v_{u}^{i}))\\$.", "A multi-value guidepost allows a target expression to have multiple value choices when it is evaluated multiple times (e.g., in a loop)."]}, {"sentences": []}, {"sentences": ["Figure 4 illustrates how DeMiner generates guideposts from monitoring mutant executions and inserts them to a target program \\$p\\$.", "Suppose that DeMiner created a mutant \\$m\\$ from \\$p\\$ by changing an operator at Line 1 (i.e., \\$e\\$ is \\$\\mathrm{x}+\\mathrm{y}\\$).", "With a test cases \\$t\\$ that executes func(0, 1), Line 3 was not covered on \\$p\\$, but covered on \\$m\\$ as z is \u22121 on \\$m\\$.", "Once DeMiner finds that \\$m\\$ covers an unreached Line 3, it inserts a probe to \\$m\\$ to monitor values of the mutated expression (i.e., x - y) (Figure 4-(c)).", "By re-running \\$m\\$ with a monitoring probe, DeMiner finds that the mutated expression is evaluated to \\$-1\\ (v_{1}=-1)\\$ and expects that an execution of \\$p\\$ may cover Line 3 if \\$e\\$ is evaluated to \u22121.", "To reproduce the mutation effect, DeMiner inserts a single-value guidepost to constraint \\$\\mathrm{x}\\ + \\mathrm{y}\\$ (i.e., \\$e\\$) to become \u22121 (i.e., \\$v_{1}\\$) right before \\$e\\$."]}, {"sentences": ["Example of guidepost construction"]}, {"sentences": ["View All"]}, {"sentences": []}, {"sentences": ["Suppose that there is another test case \\$t^{\\prime}\\$ that executes func (1, 1).", "Then, DeMiner will find 0 as the second coverage-increasing value for \\$e\\$ (i.e., \\$v_{2}=0\\$).", "From the two coverage-increasing values associated, DeMiner generates a multi-value guidepost that constraints \\$x+y\\$ to become either \u22121 or 0 (Figure 4-(e))."]}, {"sentences": ["For each guidepost \\$g\\$, DeMiner generates a version of \\$p\\$ which embeds \\$g\\$."]}, {"sentences": ["The last phase takes multiple versions of \\$p\\$ each of which is augmented with a guidepost and runs concolic testing to generate test inputs.", "For the multiple versions of \\$p\\$ with guideposts (e.g., \\$g_{1}, \\ldots g_{l}\\$), DeMiner applies concolic testing to \\$p_{i} (p\\$ augmented with \\$g_{i}\\$) with each test input in \\$T\\$ as an initial test input.", "DeMiner uses a new prioritized concolic search strategy which hybridizes depth-first search (DFS) and random branch negation (RND) strategies as follows:"]}, {"sentences": ["The search algorithm first performs concolic testing using DFS until the inserted guidepost is reached.", "If the guidepost condition \\$c\\$ is violated, the target program execution immediately terminates.", "Then, the search algorithm negates the last branch condition (i.e., unsatisfied guidepost condition \\$\\neg c\\$) and generates a test execution that satisfies \\$c\\$.", "If concolic testing fails to generate a test execution satisfying \\$c\\$, the concolic testing continues to use DFS until reaching the guidepost again through a different test execution."]}, {"sentences": ["If concolic testing generates a test execution satisfying \\$c\\$, the concolic testing uses RND to negate only those branches executed after the guidepost.", "This is to focus on execution space satisfying a guidepost condition \\$c\\$ and, thus, has high probability to increase coverage."]}, {"sentences": []}]}, {"title": "Experiment Setup", "paragraphs": [{"sentences": ["We have designed the following four research questions to evaluate DeMiner in terms of increased coverage and execution time."]}, {"sentences": ["RQ1.", "With given test inputs, how many unreached lines/branches of an original program are covered by mutant executions?"]}, {"sentences": ["RQ2.", "How many unreached lines/branches of an original program are covered by DeMiner?"]}, {"sentences": ["RQ3.", "How many unreached lines/branches covered by the mutant executions are also covered by DeMiner?"]}, {"sentences": ["RQ4.", "How many unreached lines/branches of an origianl program does DeMinercover, compared to conventional concolic testing techniques?"]}, {"sentences": ["RQ5.", "To what extent does the mutant selection of DeMineraffect execution time and line/branch coverage?"]}, {"sentences": []}, {"sentences": ["RQ1 is to validate our conjecture that mutant executions cover a meaningfully large amount of unreached lines/branches that given test inputs do not cover on an original program \\$p\\$."]}, {"sentences": ["RQ2 is to check the coverage improvement of DeMiner."]}, {"sentences": ["RQ3 is to check how effectively the guideposts guide concolic testing on \\$p\\$ to cover the target unreached lines/branches covered by the coverage-increasing mutant executions."]}, {"sentences": ["Regarding RQ4, we compared DeMiner with the conventional concolic testing techniques that use three search strategies depth-first search (DFS), random branch negation (RND), and control-graph based heuristic for fast branch coverage increase (CFG) [14]."]}, {"sentences": ["RQ5 evaluates the efficiency and the effectiveness of the greedy mutant selection method of DeMiner.", "We compared DeMiner with a variant that randomly selects the same number of mutants selected by DeMiner and another variant that selects all mutants."]}, {"sentences": ["To answer RQ1 to RQ5, we performed experiments on the three real-world C programs (see Table II).", "The following subsections explain the details of the experiment setup."]}, {"sentences": ["We used recent versions of three well-known, real-world C programs as study ojects."]}, {"sentences": ["Busybox-ls is a file listing utility and Busybox-printf is a formatted data printer in BusyBox version 1.24.02.", "GNU-find is a file search utility in GNU FindUtils version 4.63.", "These three programs are utilities for UNIX-like operating systems.", "Table II shows the size of the target code in executable lines (LoC) and branches, a number of given test cases used, and line and branch coverage achieved by running the all given test cases for each study object."]}, {"sentences": []}, {"sentences": ["All test cases were obtained from the regression test suites in the program packages.", "The experiments use all test cases given in the package, except 11 test cases of GNU-find due to technical difficulties4.", "We used gcov to measure LoC, and the line and the branch coverage throughout the experiments."]}, {"sentences": ["DeMiner generates mutants of a target program using a C source code mutation tool MUSIC [15] (see Section IV-D).", "After mutant generation, DeMiner eliminate trivially equivalent and duplicated mutants [16].", "An equivalent mutant is identified by checking whether or not the MD5 checksum of the compiled binary object is the same as that of the original target program.", "Similarly, two mutants are identified as duplicated if their compiled binary objects have the same MD5 checksum value."]}, {"sentences": ["The experiments used all generated mutants for Busybox-ls and Busybox-printf, To save experiment time, the experiments with GNU-find randomly select and use five mutants per code line, because a total amount of time spent for the experiments on GNU-find will be significantly larger than that of Busybox-ls or Bubybox-printf."]}, {"sentences": ["We declared command-line arguments and file-metadata such as file mode, file size, permission, modification time as symbolic inputs for concolic testing.", "Table III shows the symbolic input setup for the study objects.", "The second column shows the maximum number of symbolic command-line arguments, and the third column shows the maximum length of each symbolic command-line argument of the experiment setup.", "A number of symbolic file-metadata structures is same to a number of files used in a given regression test case.", "The last column shows the maximum number of symbolic file-metadata structures in the experiments.", "Each symbolic file-metadata consists of 13 symbolic integer variables (Busybox-printf does not use symbolic file-metadata because it does not take a file as an input)."]}, {"sentences": []}, {"sentences": ["For each pair of a generated guidepost \\$g_{i}\\$ and a given test case \\$t_{j}\\$, DeMiner applies concolic testing to a target program having \\$g_{i}\\$ with \\$t_{j}\\$ as an initial seed test case for generating 500 test cases further."]}, {"sentences": ["In addition, we compared DeMiner with the conventional concolic testing techniques with three search strategies DFS, RND, and CFG.", "They also use the given test cases as initial seed test cases.", "For fair comparison, we run each of the three concolic testing techniques for the same amount of time that DeMiner consumes which includes the followings:"]}, {"sentences": ["mutant generation and selection"]}, {"sentences": ["mutant executions with the given test cases"]}, {"sentences": ["guidepost constructions"]}, {"sentences": ["guided concolic testing for 500 test cases per guidepost and initial test case."]}, {"sentences": []}, {"sentences": ["For example of Busybox-printf, as DeMiner spent total 23,394 seconds, each of the three conventional concolic testing techniques is executed for 23,394 seconds with the 17 initial test cases (i.e., for each initial test case, a conventional technique is executed for 1,376 seconds (=23494/17))."]}, {"sentences": ["The DeMiner implemenentation is written in C++ and Python.", "The component for mutation analyses (i.e., in Phase 1, see Section III-B) consists of the mutant generation part and the mutant execution part.", "For mutant generation, we used MUSIC (MUtation analySIs tool with high Confiurability and extensibility) [15].", "5 MUSIC implements 73 expression-level and statement-level mutation operators for modern C programs (63 of them are defined in Agrawal et al.", "[13]).", "MUSIC preserves the source code line numbering in an expression-level mutation to make coverage information on mutants and the original program comparable.", "The mutant execution part is implemented in 540 lines of Python script code."]}, {"sentences": ["The component for guidepost construction (i.e., Phase 2) is implemented in 1,620 lines of C++ code using Clang/LLVM 3.4 [19].", "The component for guided concolic testing (i.e., Phase 3) is implemented upon CROWN [20].", "CROWN (Concolic testing for Real-wOrld softWare aNalysis) is a lightweight easy-to-customize concolic testing tool for real-world C programs, which is extended from CREST-BV [21].", "It supports complex C features such as bitwise operators, floating point arithmetic, bitfields and so on.", "We added 230 lines of C/C++ code to implement the prioritized search strategy which hybridizes DFS and RND (see Section III-D)."]}, {"sentences": ["Diagrams showing the relation among coverages by regression test cases (\\$C_{0}\\$), mutant executions (\\$C_{\\mu}\\$), and DeMiner (\\$C_{D}\\$)"]}, {"sentences": ["View All"]}, {"sentences": []}, {"sentences": ["All the experiments were performed on machines equipped with Intel quad-core i5 4670K and 8GB ram, running Ubuntu 16.04.3 64 bit version.", "For each mutant execution, we setup timeout as 0.5 seconds which is almost 10 times of the average execution time of each regression test execution time."]}, {"sentences": ["To limit random effects of the greedy coverage-increasing mutant selection and the RND and CFG concolic searcch strategies, we repeated the same experiment five times and report the average of the results."]}, {"sentences": ["We used gcov to measure line and branch coverage.", "Since MUSIC performs line-preserving mutation (Section IV-D) and DeMiner uses only expression level mutation operators (Section III-B), covered line/branch information of a generated mutant is comparable to that of an original target program."]}, {"sentences": ["A primary threat to external validity is the representativeness of the study objects used for the experiments, because we have examined only three C programs.", "We believe that this threat is limited because the target programs are non-trivial real-world C programs which have different characteristics.", "We will address this threat to external validity in future work by applying DeMiner to more target programs.", "Another external threat involves the representativeness of the conventional concolic testing techniques that we compared with DeMiner (DeMiner might yield different results compared to concolic testing techniques other than DFS, RND, and CFG).", "We think that this threat is limited because these three search strategies are representative ones for concolic testing."]}, {"sentences": ["A primary threat to internal validity is possible bugs in the implementation of DeMiner.", "Since we have spent significant effort for testing and debugging the implementation, we believe that this threat is limited."]}]}, {"title": "Experiment Results", "paragraphs": [{"sentences": ["This sections describes the results of the experiments to answer the research questions in Section IV.", "Note that, in the following discussion, we denote the sets of lines/branches covered by the given test cases as \\$C_{0}\\$, and that of all mutant executions as \\$C_{\\mu}\\$, and that achieved by DeMiner as \\$C_{D}\\$."]}, {"sentences": []}, {"sentences": ["Figure 5 shows the relation among \\$C_{0},\\ C_{\\mu}\\$, and \\$C_{D}\\$"]}, {"sentences": ["The experiment results on RQ1 show that mutation effectively diversifies program executions in a large degree, so that many unreached lines and branches are covered on the mutants with the given test cases.", "(i.e., \\$\\vert C_{\\mu}-C_{0}\\vert > > 0\\$ in Figure 5)."]}, {"sentences": ["Table IV shows the results on coverage-increasing mutants.", "The second column shows a number of all mutants used for the experiments, and the third column shows the number of coverage-increasing mutants.", "The forth and the fifth columns report a number of the lines and branches that are covered by at least one mutant execution, respectively (i.e., \\$\\vert C_{\\mu}\\vert\\$)."]}, {"sentences": ["The results shows that, with the same given test cases, the executions on mutants cover meaningfully large amount of additional lines and branches compared to the execution on the original program.", "For example of GNU-find, the given 120 test cases cover 2,505 lines on the 172 mutants (i.e., covering 313 (=2505-2192) more lines than the original program).", "The mutant executions increase line coverage by 41.2% (=(363-257)/257), 16.4% (=(163-140)/140), and 14.3% (=(2505-2192)/2192) for Busybox-ls, Busybox-printf, and GNU-find, respectively.", "Also, the mutant executions improve branch coverage by 83.0% (=(247-135)/135), 32.0% (=(99-75)/75) and 18.5% (=(1257-1061)/1061) for Busybox-ls, Busybox-printf, and GNU-find, respectively.", "Note that these coverage increments appear on the mutants, not on the original target program."]}, {"sentences": ["The experiment results on RQ2 show that DeMiner effectively increases test coverage by utilizing the knowledge on the mutant executions."]}, {"sentences": ["In Table V, the second column represents a number of generated guideposts for each study object.", "The third and forth columns show a total numbers of lines and branches that DeMiner covers in generating 500 test cases for each guidepost with each initial test case, respectively."]}, {"sentences": ["For example of Busybox-ls, DeMiner generates 3,087 guideposts and covers 348 lines, which increases coverage of all given test cases by 35.4% (=(348-257)/257).", "For Busybox-printf and GNU-find, DeMiner increases line coverage 15.0% (=(161-140)/140) and 12.1% ((2458-2192)/2192), respectively.", "In addition, it increases branch coverage of Busybox-ls, Busybox-printf, and GNU-find by 71.1% (=(231-135)/135), 24.0% (=(93-75)/75), and 12.9% (=(1198-1061)/1061), respectively."]}, {"sentences": []}, {"sentences": ["Table VI compares the coverage of the mutant executions and DeMiner.", "The third and fourth columns show a number of the unreached lines/branches covered by mutant executions (i.e., \\$\\vert C_{\\mu}-C_{0}\\vert\\$) and DeMiner (i.e., \\$\\vert C_{D}-C_{0}\\vert\\$), respectively.", "The fifth column shows a number of the unreached lines/branches covered by both mutant executions and DeMiner (i.e., \\$\\vert (C_{D}-C_{0})\\cap(C_{\\mu}-C_{0})\\vert\\$)"]}, {"sentences": ["For example of Busybox-ls, DeMiner covers \\$85.8\\% (=\\frac{\\vert (C_{D}-C_{0})\\cap(C_{\\mu}-C_{0})\\vert}{\\vert C_{\\mu}-C_{0}\\vert}=91/106)\\$ of the unreached lines covered by the mutant executions.", "For Busybox-printf and GNU-find, DeMiner covers 91.3% (=21/23) and 80.2% (=251/313) of the unreached lines that the mutant executions cover (see the fifth column).", "Similarly, for Busybox-ls, Busybox-printf, and GNU-find, it covers 85.7% (=96/112), 75.0% (=18/24), and 55.1% (=108/196) of the unreached branches that the mutant executions cover (see the third and fifth columns)."]}, {"sentences": ["This result shows that the guideposts effectively guide concolic testing in DeMiner to cover most unreached lines and branches covered by the mutation executions.", "Note that, for GNU-find, DeMiner covers 15 lines (=266-251) and 29 branches (=137-108) which are covered neither by the initial test cases nor by the mutant executions.", "This fresh coverage increase is because DeMiner can explore diverse execution space beyond the ones reached by the mutant executions.", "Regarding Busybox-ls and Busy-printf which has relatively smaller execution space than GNU-find, we conjecture that there exist only too few lines/branches left for DeMiner to cover beyond the mutant executions."]}, {"sentences": []}, {"sentences": ["Table VII compares the coverage achievements of DeMiner with the three conventional concolic testing techniques.", "The third to fifth columns show the number of newly covered lines/branches (compared to the initial test cases) by concolic testing with DFS, RND, and CFG search strategies, respectively.", "The last column represents the result of DeMiner."]}, {"sentences": ["The experiment results show that DeMiner covers more lines and branches than all three studied concolic testing techniques."]}, {"sentences": ["For example of Busybox-ls, DeMiner covered 96 unreached branches which are 14.3% (=(96-84)/84) more branches than the conventional concolic testing using DFS, which is the best conventional concolic testing technique for Busybox-ls.", "Similarly, for Busybox-printf and GNU-find, DeMiner outperformed the three concolic testing techniques by covering 20.0% (=(18-15)/15) and 39.8% (=(137-98)/98) more unreached branches than CFG and RND which are the best concolic testing techniques for Busybox-printf and GNU-find, respectively.6 On average, the amount of the improved branch coverage by DeMiner is \\$24.7\\%\\ (=(14.3+20.0+39.8)/3)\\$ relatively larger than those of the conventional concolic testing techniques."]}, {"sentences": ["In addition, Figure 6 shows the increase of covering unreached lines for 1,000 test input generations of the three conventional concolic testing techniques and DeMiner.", "The X-axis represents a number of test cases generated by DeMiner for each guided concolic testing instance (i.e., concolic testing of a target program having one guidepost using one initial test case).", "The Y-axis represents a number of unreached lines covered."]}, {"sentences": ["The result shows that, for all target programs and all levels of the numbers of generated test cases, DeMiner always covers the largest number of unreached lines among the conventional concolic testing techniques.", "For example of GNU-find with 1,000 test cases generation, DeMiner covers the unreached lines around 27% (=(332-261)/261) more than the best conventional concolic testing technique (i.e., RND) (see the right end of the find graph in the figure)."]}, {"sentences": ["The number of unreached lines covered with different numbers of test cases generated per different techniques"]}, {"sentences": ["View All"]}, {"sentences": []}, {"sentences": ["Table VIII shows the effects of the coverage-increasing mutant selection.", "The second to fourth columns show the line and branch coverage that DeMiner achieves with the greedy mutant selection algorithm, a random mutant selection which selects the same number of mutants selected by the greedy one, and using all coverage-increasing mutants, respectively.", "The fifth to seventh columns show the execution time in hours taken by DeMiner with the corresponding methods."]}, {"sentences": ["The experiment results show that the greedy selection of the mutants effectively reduces the runtime cost without hurting coverage much (except GNU-find)7.", "DeMiner with the greedy mutant selection consumes only 1.2% (=9.5/776.5) (Busybox-ls) to 5.3% (=6.5/123.8) (Busybox-printf) of the execution time of DeMiner with all coverage-increasing mutants."]}, {"sentences": ["Also, DeMiner with the greedy selection covers more lines and branches than DeMiner with random selection for all cases.", "For example of Busybox-ls, DeMiner with the greedy mutant selection covers 91 unreached lines while DeMiner with the random selection does only 85 lines."]}, {"sentences": ["An example of hard-to-reach lines of Busybox-printf for conventional concolic testing"]}, {"sentences": ["View All"]}, {"sentences": []}]}, {"title": "Discussion", "paragraphs": [{"sentences": ["Figure 7 shows an example of hard-to-reach lines of Busybox-printf for conventional concolic testing.", "print_direc takes a character pointer format which points to a character array whose elements are symbolic input characters as the first parameter (Line 160).", "print_direc assigns a symbolic input character of format to ch (Line 169).", "Then, it calls strstr to check if format contains \u2018.\u2019 or \u2018*\u2019(Line 172) and calls strchr to get a position of \u2018*\u2019 in format (Line 173).", "print_direc converts input data according to the format string character using switch statement on Line 179.", "Lines 202\u2013203 are not covered by the regression test inputs provided in Busybox-printf 1.24.0."]}, {"sentences": ["Conventional concolic testing using DFS and RND could not cover Lines 202\u2013203 in 23,394 seconds, due to the loops inside strstr at Line 172 and strchr at Line 173.", "Both of the loops have symbolic variables in their loop conditions, because they iterate over a symbolic input string format until they reach any specified character (i.e., \u2018.\u2019, \u2018*\u2019, or \u2018\\0\u2019).", "Therefore, conventional concolic testing keeps increasing the loop bound and fails to cover Lines 202\u2013203 within a given time bound."]}, {"sentences": ["Note that DeMiner covers these hard-to-cover lines as follows.", "DeMiner generates a mutant \\$m\\$ which mutates a variable fmt_length to another variable precision.", "One of the mutant executions of \\$m\\$ covers Lines 202\u2013203 and the monitoring probe for \\$m\\$ (i.e., probe (format [precision]) at right before Line 169) reports \u2018X\u2019 as a value of the mutated target expression.", "Using the reported value \u2018X\u2019, DeMiner inserts a guidepost at Line 168 and guided concolic testing of DeMiner tries to satisfy the guidepost condition with high priority instead of negating branches of the loops inside strstr and strchr at Lines 172\u2013173 (see Section III-D).", "Therefore, DeMiner effectively covers Lines 202\u2013203."]}, {"sentences": ["Furthermore, for GNU-find, DeMiner covers 16 lines that seems not reachable by the conventional concolic testing by any means.", "We ran each of the conventional concolic testing techniques using DFS, RND and CFG for one week (i.e., 168 hours) per each initial test case (i.e., execution time is 120 weeks in total).", "Then, we found that there are 16 lines which are covered by DeMiner, but they were never covered by any test executions by conventional concolic techniques with 120 weeks of the testing time.", "DeMiner can cover these 16 lines successfully because the guideposts prune the search space that is not relevant to cover new lines, and effectively guide concolic testing toward execution paths that reach unreached lines observed from diverse coverage-increasing mutant executions."]}, {"sentences": ["Program mutation has been a popular method for evaluating how given test cases detect subtle program changes.", "Traditional research on software mutation [22] mainly focuses on evaluating bug finding effectiveness of a test suite by measuring how many mutants the test suite can kill."]}, {"sentences": ["Fraser and Zeller [23] presents a search-based unit test generation technique that targets mutants as a way to generate diverse unit tests.", "The technique directs test case generation toward finding output and coverage differences between a target program and its mutants.", "Both our approach and that by Fraser and Zeller [23] are common in that both analyze mutant executions.", "The difference is that in our approach, the dynamic information on mutants is used for inferring internal conditions of a target program to increase test coverage, rather than measuring the difference between the target program and a mutant."]}, {"sentences": ["Program mutation has also been used to generate and evaluate test oracles.", "Mutation analysis is used to examine which properties are invariants of the correct program.", "Fraser and Zeller [23] utilizes mutation analysis to infer test oracles from the mutant execution information.", "Jahangirova et al.", "[24] presents a method to assess and improve the quality of a given test oracle by utilizing program mutation.", "Recently, mutation analysis has been used to precisely localize a fault in a program.", "Mutation-based fault localization [25]\u2013[26][27][28] locates a fault in the target program code by observing how the behaviors of the faulty program change according to the program code chances."]}, {"sentences": ["A few research work have focused on mutating program code or runtime states to derive diverse executions for better dynamic analyses [29], [30].", "These techniques utilize values and execution paths observed from mutated program executions directly during the analyses of the original program without validating whether these observations also hold for the original program.", "Thus, these techniques may produce unsound analysis results because mutated program executions may be infeasible on the original program."]}, {"sentences": ["Our approach alleviates this false positive problem by generating only feasible test inputs by leveraging concolic testing techniques with the discovered knowledge from the mutation analyses."]}]}, {"title": "Conclusion", "paragraphs": [{"sentences": ["This paper presents DeMiner which is an automated test generation technique that realizes the invasive software testing paradigm by utilizing information from diverse mutant executions.", "We demonstrated that DeMiner can effectively increase test coverage by applying DeMiner to three real-world C programs."]}, {"sentences": ["We plan to extend DeMiner in the following directions.", "First, to enhance the knowledge discovery, we will improve DeMiner to employ more mutation operators, including statement-level and higher-order mutation operators.", "Second, to learn the converage-increasing conditions more efficiently and effectively, we will utilize the automated unit test generation technique using concolic testing [31] which can generate the coverage-increasing conditions at an entry of a function.", "Third, we will leverage program invariant inference techniques, such as Daikon [32], to generate various kinds of guideposts from mutant execution information.", "In addition, we will explore what kinds of guidepost condition structures are effective for capturing useful knowledge from mutant executions.", "Finally, we will apply DeMiner to more real-world programs to show that DeMiner is generally effective in finding unknown bugs in real-world programs."]}]}]