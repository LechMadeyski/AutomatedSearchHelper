@article{doi:10.1002/stvr.1728,
author = {Delgado-Pérez, Pedro and Sánchez, Ana Belén and Segura, Sergio and Medina-Bulo, Inmaculada},
title = {Performance mutation testing},
journal = {Software Testing, Verification and Reliability},
volume = {n/a},
number = {n/a},
pages = {e1728},
keywords = {mutation testing, performance bugs, performance testing, software testing},
doi = {10.1002/stvr.1728},
url = {https://onlinelibrary.wiley.com/doi/abs/10.1002/stvr.1728},
eprint = {https://onlinelibrary.wiley.com/doi/pdf/10.1002/stvr.1728},
note = {e1728 stvr.1728},
abstract = {Summary Performance bugs are known to be a major threat to the success of software products. Performance tests aim to detect performance bugs by executing the program through test cases and checking whether it exhibits a noticeable performance degradation. The principles of mutation testing, a well-established testing technique for the assessment of test suites through the injection of artificial faults, could be exploited to evaluate and improve the detection power of performance tests. However, the application of mutation testing to assess performance tests, henceforth called performance mutation testing (PMT), is a novel research topic with numerous open challenges. In previous papers, we identified some key challenges related to PMT. In this work, we go a step further and explore the feasibility of applying PMT at the source-code level in general-purpose languages. To do so, we revisit concepts associated with classical mutation testing and design seven novel mutation operators to model known bug-inducing patterns. As a proof of concept, we applied traditional mutation operators as well as performance mutation operators to open-source C++ programs. The results reveal the potential of the new performance-mutants to help assess and enhance performance tests when compared with traditional mutants. A review of live mutants in these programs suggests that they can induce the design of special test inputs. In addition to these promising results, our work brings a whole new set of challenges related to PMT, which will hopefully serve as a starting point for new contributions in the area.}
}
@article{doi:10.1002/stvr.1471,
author = {Mateo, Pedro Reales and Usaola, Macario Polo},
title = {Parallel mutation testing},
journal = {Software Testing, Verification and Reliability},
volume = {23},
number = {4},
pages = {315-350},
keywords = {mutation testing, parallel execution},
doi = {10.1002/stvr.1471},
url = {https://onlinelibrary.wiley.com/doi/abs/10.1002/stvr.1471},
eprint = {https://onlinelibrary.wiley.com/doi/pdf/10.1002/stvr.1471},
abstract = {SUMMARYDespite the existing techniques to reduce the costs of mutation analysis, the computational cost to apply mutation testing with large applications can be very high. One effective technique to improve the efficiency of mutation without losing effectiveness is parallel execution, where mutants and tests are executed in parallel processors, reducing the total time needed to perform mutation analysis. This paper presents a study of this technique adapted to current technologies. Five algorithms to execute mutants in parallel are analysed with three studies that use different network configurations and different number of processors with diverse characteristics. The experiments are performed with Bacterio P, a tool that is also presented. Unlike previous studies about parallel mutant execution, which date from the mid-1990s, in the studies in this paper, the communication time in parallel systems no longer acts as a bottleneck. Thus, dynamic strategies, which require more communication, combined with other mutant cost reduction techniques, are the best strategies to run mutants in parallel.Copyright © 2012 John Wiley \& Sons, Ltd.},
year = {2013}
}
@article{doi:10.1002/stvr.1469,
author = {Gligoric, Milos and Jagannath, Vilas and Luo, Qingzhou and Marinov, Darko},
title = {Efficient mutation testing of multithreaded code},
journal = {Software Testing, Verification and Reliability},
volume = {23},
number = {5},
pages = {375-403},
keywords = {mutation testing, multithreaded code},
doi = {10.1002/stvr.1469},
url = {https://onlinelibrary.wiley.com/doi/abs/10.1002/stvr.1469},
eprint = {https://onlinelibrary.wiley.com/doi/pdf/10.1002/stvr.1469},
abstract = {SUMMARYMutation testing is a well-established method for measuring and improving the quality of test suites. A major cost of mutation testing is the time required to execute the test suite on all the mutants. This cost is even greater when the system under test is multithreaded: not only are test cases from the test suite executed on many mutants but also each test case is executed—or more precisely, explored—for multiple possible thread schedules. This paper introduces a general framework for efficient exploration that can reduce the time for mutation testing of multithreaded code. The paper presents five techniques (four optimizations and one heuristic) that are implemented in a tool called MuTMuT within the general framework. Evaluation of MuTMuT on mutation testing of 12 multithreaded programs shows that it can substantially reduce the time required for mutation testing of multithreaded code.Copyright © 2012 John Wiley \& Sons, Ltd.},
year = {2013}
}
@article{doi:10.1002/stvr.1528,
author = {Estero-Botaro, Antonia and Palomo-Lozano, Francisco and Medina-Bulo, Inmaculada and Domínguez-Jiménez, Juan José and García-Domínguez, Antonio},
title = {Quality metrics for mutation testing with applications to WS-BPEL compositions},
journal = {Software Testing, Verification and Reliability},
volume = {25},
number = {5-7},
pages = {536-571},
keywords = {mutation testing, firm mutation, quality metrics, quality of mutation operators, service compositions, WS-BPEL},
doi = {10.1002/stvr.1528},
url = {https://onlinelibrary.wiley.com/doi/abs/10.1002/stvr.1528},
eprint = {https://onlinelibrary.wiley.com/doi/pdf/10.1002/stvr.1528},
abstract = {SummaryMutation testing is a successful testing technique based on fault injection. However, it can be very costly, and several cost-reduction techniques for reducing the number of mutants have been proposed in the literature. Cost reduction can be aided by an analysis of mutation operators, but this requires the definition of specialized metrics. Several metrics have been proposed before, although their effectiveness and relative merits are not easy to assess. A step ahead in the evaluation of mutation-reduction techniques would be a better metric to determine objectively the quality of a set of mutants with respect to a given test suite. This work introduces such a metric, which is naturally extended to mutation operators and may be used to reduce the number of mutants, particularly of equivalent mutants. Finally, a firm mutation analysis tool for WS-BPEL service compositions is presented, and experimental results obtained by comparing different metrics on several compositions are presented. Copyright © 2014 John Wiley \& Sons, Ltd.},
year = {2015}
}
@article{doi:10.1002/stvr.1531,
author = {Dadeau, Frédéric and Héam, Pierre-Cyrille and Kheddam, Rafik and Maatoug, Ghazi and Rusinowitch, Michael},
title = {Model-based mutation testing from security protocols in HLPSL},
journal = {Software Testing, Verification and Reliability},
volume = {25},
number = {5-7},
pages = {684-711},
keywords = {mutation testing, security protocols, HLPSL, AVISPA, test generation},
doi = {10.1002/stvr.1531},
url = {https://onlinelibrary.wiley.com/doi/abs/10.1002/stvr.1531},
eprint = {https://onlinelibrary.wiley.com/doi/pdf/10.1002/stvr.1531},
abstract = {Any abstract. Two sentences.},
year = {2015}
}
@article{doi:10.1002/spe.2629,
author = {Gutiérrez-Madroñal, Lorena and García-Domínguez, Antonio and Medina-Bulo, Inmaculada},
title = {Evolutionary mutation testing for IoT with recorded and generated events},
journal = {Software: Practice and Experience},
volume = {49},
number = {4},
pages = {640-672},
keywords = {CEP, event processing language, evolutionary mutation testing, genetic algorithm, guided evolutionary mutation testing, internet of things, IoT-TEG},
doi = {10.1002/spe.2629},
url = {https://onlinelibrary.wiley.com/doi/abs/10.1002/spe.2629},
eprint = {https://onlinelibrary.wiley.com/doi/pdf/10.1002/spe.2629},
note = { spe.2629},
abstract = {Summary Mutation testing is a testing technique that has been applied successfully to several programming languages. Despite its benefits for software testing, the high computational cost of mutation testing has kept it from being widely used. Several refinements have been proposed to reduce its cost by reducing the number of generated mutants; one of those is evolutionary mutation testing (EMT). Evolutionary mutation testing aims at generating a reduced set of mutants with an evolutionary algorithm, which searches for potentially equivalent and difficult to kill mutants that help improve the test suite. Evolutionary mutation testing has been evaluated in two contexts so far, ie, web service compositions and object-oriented C++ programmes. This study explores its performance when applied to event processing language queries of various domains. This study also considers the impact of the test data, since a lack of events or the need to have specific values in them can hinder testing. The effectiveness of evolutionary mutation testing with the original test data generators and the new internet of things test event generator tool is compared in multiple case studies.},
year = {2019}
}
@article{doi:10.1002/stvr.1675,
author = {Zhu, Qianqian and Panichella, Annibale and Zaidman, Andy},
title = {A systematic literature review of how mutation testing supports quality assurance processes},
journal = {Software Testing, Verification and Reliability},
volume = {28},
number = {6},
pages = {e1675},
keywords = {application, mutation testing, systematic literature review},
doi = {10.1002/stvr.1675},
url = {https://onlinelibrary.wiley.com/doi/abs/10.1002/stvr.1675},
eprint = {https://onlinelibrary.wiley.com/doi/pdf/10.1002/stvr.1675},
note = {e1675 stvr.1675},
abstract = {Summary Mutation testing has been very actively investigated by researchers since the 1970s, and remarkable advances have been achieved in its concepts, theory, technology, and empirical evidence. While the most influential realisations have been summarised by existing literature reviews, we lack insight into how mutation testing is actually applied. Our goal is to identify and classify the main applications of mutation testing and analyse the level of replicability of empirical studies related to mutation testing. To this aim, this paper provides a systematic literature review on the application perspective of mutation testing based on a collection of 191 papers published between 1981 and 2015. In particular, we analysed in which quality assurance processes mutation testing is used, which mutation tools and which mutation operators are employed. Additionally, we also investigated how the inherent core problems of mutation testing, ie, the equivalent mutant problem and the high computational cost, are addressed during the actual usage. The results show that most studies use mutation testing as an assessment tool targeting unit tests, and many of the supporting techniques for making mutation testing applicable in practice are still underdeveloped. Based on our observations, we made 9 recommendations for future work, including an important suggestion on how to report mutation testing in testing experiments in an appropriate manner.},
year = {2018}
}

@inbook{doi:10.1002/0471028959.sof217,
author = {Mathur, Aditya P.},
publisher = {American Cancer Society},
isbn = {9780471028956},
title = {Mutation Testing},
booktitle = {Encyclopedia of Software Engineering},
chapter = {},
pages = {},
doi = {10.1002/0471028959.sof217},
url = {https://onlinelibrary.wiley.com/doi/abs/10.1002/0471028959.sof217},
eprint = {https://onlinelibrary.wiley.com/doi/pdf/10.1002/0471028959.sof217},
year = {2002},
keywords = {history, mutation operators, comparisons, tools, performance, applications},
abstract = {Abstract Mutation testing, hereafter referred to as mutation, is a technique for software testing. Specifically, it provides a tester with one or more measures of “goodness” of a test set. Such goodness measures are also known as test adequacy criteria. A test set may consist of zero or more test cases, where each test case is a set of values input to the program under test. Several other testing techniques also provide one or more adequacy criteria. For example, path-based testing methods provide statement coverage as one adequacy criterion. This criterion is satisfied by a test set if each statement in the program under test is executed at least once by one or more of its elements. Mutation differs significantly from path-oriented testing techniques in terms of the ways in which it examines and manipulates the program syntax. Mutation introduces a simple syntactic change in the program under test. The program thus produced is known as a mutant. More than one mutant is usually generated by making various types of simple syntactic changes at different places in the program. The goal of the tester is to find a test case that causes the mutant to generate an output different from that of the program under test thereby distinguishing the mutant from the program. The adequacy of a test set is measured by how many mutants can be distinguished collectively by the tests that belong to .}
}@article{doi:10.1002/stvr.1582,
author = {Jia, Yue and Merayo, Mercedes and Harman, Mark},
title = {Introduction to the special issue on Mutation Testing},
journal = {Software Testing, Verification and Reliability},
volume = {25},
number = {5-7},
pages = {461-463},
doi = {10.1002/stvr.1582},
url = {https://onlinelibrary.wiley.com/doi/abs/10.1002/stvr.1582},
eprint = {https://onlinelibrary.wiley.com/doi/pdf/10.1002/stvr.1582},
note = { stvr.1582},
year = {2015}
}
@article{doi:10.1002/stvr.1697,
author = {Just, René and Krinke, Jens and Li, Nan and Rojas, José Miguel},
title = {Special issue on mutation testing and analysis},
journal = {Software Testing, Verification and Reliability},
volume = {29},
number = {1-2},
pages = {e1697},
doi = {10.1002/stvr.1697},
url = {https://onlinelibrary.wiley.com/doi/abs/10.1002/stvr.1697},
eprint = {https://onlinelibrary.wiley.com/doi/pdf/10.1002/stvr.1697},
year = {2019}
}
@article{doi:10.1002/spe.4380200205,
author = {Spafford, Eugene H.},
title = {Extending mutation testing to find environmental bugs},
journal = {Software: Practice and Experience},
volume = {20},
number = {2},
pages = {181-189},
keywords = {Testing, Mutation analysis, Environmental bugs},
doi = {10.1002/spe.4380200205},
url = {https://onlinelibrary.wiley.com/doi/abs/10.1002/spe.4380200205},
eprint = {https://onlinelibrary.wiley.com/doi/pdf/10.1002/spe.4380200205},
abstract = {Abstract Environmental bugs are bugs caused by limitations of precision or capacity in the environment of a piece of software. These bugs may be difficult to activate and even more difficult to find. This paper reports on an extension to traditional mutation testing that enables testing specifically for environmental bugs involving integer arithmetic. This method is both simple and effective, and provides some insight into other possible extensions of the mutation-testing methodology that can be used to expose environmental bugs.},
year = {1990}
}
@article{doi:10.1002/stvr.241,
author = {Wong, W. Eric},
title = {Editorial: Mutation 2000—A Symposium on Mutation Testing},
journal = {Software Testing, Verification and Reliability},
volume = {11},
number = {4},
pages = {205-206},
doi = {10.1002/stvr.241},
url = {https://onlinelibrary.wiley.com/doi/abs/10.1002/stvr.241},
eprint = {https://onlinelibrary.wiley.com/doi/pdf/10.1002/stvr.241},
year = {2001}
}
@article{doi:10.1002/stvr.4370010305,
author = {Woodward, M R},
title = {Concerning ordered mutation testing of relational operators},
journal = {Software Testing, Verification and Reliability},
volume = {1},
number = {3},
pages = {35-40},
keywords = {Mutation analysis, Ordered mutation, Relational operator mutants},
doi = {10.1002/stvr.4370010305},
url = {https://onlinelibrary.wiley.com/doi/abs/10.1002/stvr.4370010305},
eprint = {https://onlinelibrary.wiley.com/doi/pdf/10.1002/stvr.4370010305},
abstract = {Abstract The aim of this paper is to correct a misapprehension concerning mutation testing of relational operators in imperative programming languages. An apparently plausible, but fallacious argument is stated concerning the order in which mutants are best considered. Subsequently, a counter-example is presented which disproves the argument.},
year = {1991}
}
@article{doi:10.1002/stvr.1522,
author = {Aichernig, Bernhard K. and Brandl, Harald and Jöbstl, Elisabeth and Krenn, Willibald and Schlick, Rupert and Tiran, Stefan},
title = {Killing strategies for model-based mutation testing},
journal = {Software Testing, Verification and Reliability},
volume = {25},
number = {8},
pages = {716-748},
keywords = {test case generation, model-based testing, mutation testing, random testing, ioco, action systems, Unified Modeling Language, UML},
doi = {10.1002/stvr.1522},
url = {https://onlinelibrary.wiley.com/doi/abs/10.1002/stvr.1522},
eprint = {https://onlinelibrary.wiley.com/doi/pdf/10.1002/stvr.1522},
abstract = {Summary This article presents the techniques and results of a novel model-based test case generation approach that automatically derives test cases from UML state machines. The main contribution of this article is the fully automated fault-based test case generation technique together with two empirical case studies derived from industrial use cases. Also, an in-depth evaluation of different fault-based test case generation strategies on each of the case studies is given and a comparison with plain random testing is conducted. The test case generation methodology supports a wide range of UML constructs and is grounded on the formal semantics of Back's action systems and the well-known input–output conformance relation. Mutation operators are employed on the level of the specification to insert faults and generate test cases that will reveal the faults inserted. The effectiveness of this approach is shown and it is discussed how to gain a more expressive test suite by combining cheap but undirected random test case generation with the more expensive but directed mutation-based technique. Finally, an extensive and critical discussion of the lessons learnt is given as well as a future outlook on the general usefulness and practicability of mutation-based test case generation. Copyright © 2014 John Wiley \& Sons, Ltd.},
year = {2015}
}
@article{doi:10.1111/j.1749-6632.1999.tb08599.x,
author = {NICHOLSON, GARTH A.},
title = {Mutation Testing in Charcot-Marie-Tooth Neuropathy},
journal = {Annals of the New York Academy of Sciences},
volume = {883},
number = {1},
pages = {383-388},
doi = {10.1111/j.1749-6632.1999.tb08599.x},
url = {https://onlinelibrary.wiley.com/doi/abs/10.1111/j.1749-6632.1999.tb08599.x},
eprint = {https://onlinelibrary.wiley.com/doi/pdf/10.1111/j.1749-6632.1999.tb08599.x},
abstract = {ABSTRACT: In order to determine the optimal approach for mutation testing in the form of Charcot-Marie-Tooth (CMT) neuropathy, consecutive patients with a CMT phenotype, available family history information on at least first-degree relatives, and median motor conduction velocities of less than 50 m/sec were tested for the CMT1A duplication and for connexin32, peripheral myelin protein 22 (PMP22) and myelin protein zero (P0) point mutations. A cutoff value for median motor conduction velocity of less than 50 m/sec was adopted to include all CMTX families. All of the connexin32 mutations, except for one sporadic case, were found by first selecting families with no male-to-male inheritance of CMT and neurophysiological indicators of CMTX. All PMP22 and P0 mutations were found by selecting Dejerine-Sottas cases or dominantly inherited CMT1 with a very severe phenotype. It is concluded that “blind” testing of CMT1 families for connexin32, P0, and PMP22 mutations is of limited value.},
year = {1999}
}
@article{doi:10.1002/(SICI)1097-024X(199602)26:2<165::AID-SPE5>3.0.CO;2-K,
author = {Offutt, A. Jefferson and Pan, Jie and Tewary, Kanupriya and Zhang, Tong},
title = {An Experimental Evaluation of Data Flow and Mutation Testing},
journal = {Software: Practice and Experience},
volume = {26},
number = {2},
pages = {165-176},
keywords = {software testing, data flow, mutation, experimentation},
doi = {10.1002/(SICI)1097-024X(199602)26:2<165::AID-SPE5>3.0.CO;2-K},
url = {https://onlinelibrary.wiley.com/doi/abs/10.1002/%28SICI%291097-024X%28199602%2926%3A2%3C165%3A%3AAID-SPE5%3E3.0.CO%3B2-K},
eprint = {https://onlinelibrary.wiley.com/doi/pdf/10.1002/%28SICI%291097-024X%28199602%2926%3A2%3C165%3A%3AAID-SPE5%3E3.0.CO%3B2-K},
abstract = {Abstract Two experimental comparisons of data flow and mutation testing are presented. These techniques are widely considered to be effective for unit-level software testing, but can only be analytically compared to a limited extent. We compare the techniques by evaluating the effectiveness of test data developed for each. We develop ten independent sets of test data for a number of programs: five to satisfy the mutation criterion and five to satisfy the all-uses data-flow criterion. These test sets are developed using automated tools, in a manner consistent with the way a test engineer might be expected to generate test data in practice. We use these test sets in two separate experiments. First we measure the effectiveness of the test data that was developed for one technique in terms of the other. Second, we investigate the ability of the test sets to find faults. We place a number of faults into each of our subject programs, and measure the number of faults that are detected by the test sets. Our results indicate that while both techniques are effective, mutation-adequate test sets are closer to satisfying the data flow criterion, and detect more faults.},
year = {1996}
}
@article{doi:10.1002/stvr.1676,
author = {Krüger, Jacob and Al-Hajjaji, Mustafa and Leich, Thomas and Saake, Gunter},
title = {Mutation operators for feature-oriented software product lines},
journal = {Software Testing, Verification and Reliability},
volume = {29},
number = {1-2},
pages = {e1676},
keywords = {composition, feature-oriented programming, mutation operator, mutation testing, software product line, unit test},
doi = {10.1002/stvr.1676},
url = {https://onlinelibrary.wiley.com/doi/abs/10.1002/stvr.1676},
eprint = {https://onlinelibrary.wiley.com/doi/pdf/10.1002/stvr.1676},
note = {e1676 stvr.1676},
abstract = {Summary Mutation testing is an approach to assess the quality of test cases. Mutants are modified versions of a system that ideally compose faulty behaviour. Test cases for a system are effective if they kill these mutants. For software product lines, several works have addressed mutation testing to inject variability faults, which may only exist in some variants. These works focus on variability models or specific implementation techniques. In contrast, feature-oriented programming has been rarely investigated, wherefore, we (1) derive corresponding mutation operators, (2) investigate the feasibility of our proposed and conventional operators on 4 software product lines, and (3) discuss open challenges in mutation testing of software product lines. The results show that our proposed operators are suitable to cause variability faults and extend the capabilities of conventional operators. Nonetheless, mutation testing of software product lines is comparably expensive, due to a high number of variants and mutants—resulting in equivalence and redundancy.},
year = {2019}
}
@article{doi:10.1002/stvr.392,
author = {Polo, Macario and Piattini, Mario and García-Rodríguez, Ignacio},
title = {Decreasing the cost of mutation testing with second-order mutants},
journal = {Software Testing, Verification and Reliability},
volume = {19},
number = {2},
pages = {111-131},
keywords = {mutation, cost reduction, mutant reduction},
doi = {10.1002/stvr.392},
url = {https://onlinelibrary.wiley.com/doi/abs/10.1002/stvr.392},
eprint = {https://onlinelibrary.wiley.com/doi/pdf/10.1002/stvr.392},
abstract = {Abstract Although powerful, mutation is a computationally very expensive testing technique. In fact, its three main stages (mutant generation, mutant execution and result analysis) require many resources to be successfully accomplished. Thus, researchers have made important efforts to reduce its costs. This paper represents an additional effort in this sense. It describes the results of two experiments in which, by means of combining the original set of mutants and therefore obtaining a new set of mutants—each one with two faults—the number of mutants used is reduced to half. Results lead to believe that mutant combination does not decrease the quality of the test suite, whereas it supposes important savings in mutant execution and result analysis. Copyright © 2008 John Wiley \& Sons, Ltd.},
year = {2009}
}
@article{doi:10.1002/stvr.1534,
author = {Mateo, Pedro Reales and Usaola, Macario Polo},
title = {Reducing mutation costs through uncovered mutants},
journal = {Software Testing, Verification and Reliability},
volume = {25},
number = {5-7},
pages = {464-489},
keywords = {mutation testing, empirical analysis, MUSIC, execution cost reduction, infinite loops},
doi = {10.1002/stvr.1534},
url = {https://onlinelibrary.wiley.com/doi/abs/10.1002/stvr.1534},
eprint = {https://onlinelibrary.wiley.com/doi/pdf/10.1002/stvr.1534},
abstract = {Summary Mutation testing is a very effective testing technique that creates mutants in order to design test cases that will kill the mutants. One problem of mutation testing is high costs: creating mutants, executing mutants and calculating the mutation score. This paper empirically analyzes the effect of covering mutants through the mutant schema improved with extra code (MUSIC) technique. This technique annotates the statements covered by the tests in the original system in order to filter the mutant executions, because tests are only executed against the mutants whose mutated statement is covered by the tests. Therefore, MUSIC is meant to reduce the number of required executions and identify infinite loops at a reduced cost. Besides, an experiment was performed to evaluate the advantages and disadvantages of analyzing the covered mutants. As a result, we conclude that analyzing the covered mutants reduces the execution cost of mutation testing and its application is therefore recommended. Copyright © 2014 John Wiley \& Sons, Ltd.},
year = {2015}
}
@article{doi:10.1002/stvr.1529,
author = {Kintis, Marinos and Papadakis, Mike and Malevris, Nicos},
title = {Employing second-order mutation for isolating first-order equivalent mutants},
journal = {Software Testing, Verification and Reliability},
volume = {25},
number = {5-7},
pages = {508-535},
keywords = {mutation testing, equivalent mutants, higher-order mutation, mutants’ impact, dynamic analysis},
doi = {10.1002/stvr.1529},
url = {https://onlinelibrary.wiley.com/doi/abs/10.1002/stvr.1529},
eprint = {https://onlinelibrary.wiley.com/doi/pdf/10.1002/stvr.1529},
abstract = {SummaryThe equivalent mutant problem is a major hindrance to mutation testing. Being undecidable in general, it is only susceptible to partial solutions. In this paper, mutant classification is utilised for isolating likely to be first-order equivalent mutants. A new classification technique, Isolating Equivalent Mutants (I-EQM), is introduced and empirically investigated. The proposed approach employs a dynamic execution scheme that integrates the impact on the program execution of first-order mutants with the impact on the output of second-order mutants. An experimental study, conducted using two independently created sets of manually classified mutants selected from real-world programs revalidates previously published results and provides evidence for the effectiveness of the proposed technique. Overall, the study shows that I-EQM substantially improves previous methods by retrieving a considerably higher number of killable mutants, thus, amplifying the quality of the testing process. Copyright © 2014 John Wiley \& Sons, Ltd.},
year = {2015}
}

